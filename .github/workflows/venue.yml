name: Build WA Venues CSV

on:
  schedule:
    - cron: '20 7 * * *'   # daily at ~07:20 UTC (12:20am Pacific)
  workflow_dispatch:

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    env:
      TM_API_KEY: ${{ secrets.TICKETMASTER_API_KEY }}
      ENABLE_WEB_SEARCH: "0"        # set "1" to attempt site discovery for missing websites (DuckDuckGo HTML)
      ENABLE_EVENT_PROOF: "1"       # require upcoming shows as part of scoring
      SONGKICK_API_KEY: ${{ secrets.SONGKICK_API_KEY }} # optional but recommended
    steps:
      - uses: actions/checkout@v4

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Build CSVs
        run: |
          node -v
          mkdir -p scripts data
          cat > scripts/build_wa_csvs.js <<'EOF'
          const fs = require('fs').promises;
          const { URL } = require('url');

          // -------------------------------
          // Filters & heuristics
          // -------------------------------
          const EXCLUDE_CATEGORIES_RE = new RegExp(
            [
              'casino',
              'perform(ing)?\\s*arts?\\s*center',
              '\\bPAC\\b',
              'museum',
              'movie\\s*(theatre|theater)|cinema|cineplex|imax|regal|amc',
              'event\\s*center|convention\\s*center|expo\\s*center|civic\\s*center',
              'fairgrounds?|fields?|stadium|ballpark|speedway|raceway|drive-?in',
              'roadhouse',
              'elk\\w*\\s*lodge|moose\\s*lodge|masonic\\s*lodge|vfw|american\\s*legion',
              'bowling|skating\\s*rink',
              'waterpark|theme\\s*park|amusement\\s*park',
              'community\\s*center|senior\\s*center|rec(reation)?\\s*center',
              'library|church|chapel|synagogue|temple'
            ].join('|'),
            'i'
          );
          const EXCLUDE_VENUE_NAME_RE = /\b(bar|pub|tavern|grill|saloon|taproom|brewery|cafe|coffee)\b/i;
          const EXCLUDE_DEFUNCT_RE = /\b(former|defunct|closed|permanently\s*closed|relocated)\b/i;
          const CLOSED_RE = /\b(permanently\s*closed|we('?ve)?\s*closed|closed\s*for\s*good|defunct|ceased\s*operations)\b/i;

          const REGION = 'West';
          const STATE = 'WA';
          const DAY_MS = 86400000;

          function escapeCSV(s='') {
            const v = String(s ?? '');
            return /[",\n]/.test(v) ? `"${v.replace(/"/g,'""')}"` : v;
          }
          function unique(arr) { return Array.from(new Set(arr.filter(Boolean))); }
          function key(name, city) { return (name||'').trim().toLowerCase()+'||'+(city||'').trim().toLowerCase(); }

          function guessVenueType(name='') {
            const s = name.toLowerCase();
            if (s.includes('amphitheat')) return 'Amphitheatre';
            if (s.includes('arena')) return 'Arena';
            if (s.includes('theatre') || s.includes('theater')) return 'Theatre';
            if (s.includes('hall')) return 'Hall';
            if (s.includes('auditorium')) return 'Auditorium';
            if (s.includes('pavilion')) return 'Pavilion';
            if (s.includes('ballroom')) return 'Ballroom';
            if (s.includes('club')) return 'Club';
            return 'Venue';
          }

          async function fetchJSON(url, headers={}) {
            const r = await fetch(url, { headers });
            if (!r.ok) throw new Error(\`HTTP \${r.status} for \${url}\`);
            return r.json();
          }
          async function fetchText(url, headers={}) {
            const r = await fetch(url, { headers });
            if (!r.ok) throw new Error(\`HTTP \${r.status} for \${url}\`);
            return r.text();
          }

          // -------- Age extraction (TM rules & Wikidata min age) --------
          function extractAge(text='') {
            const t = String(text || '').toLowerCase();
            if (!t) return '';
            if (/\ball[-\s]*ages\b/.test(t)) return 'All Ages';
            const m = t.match(/\b(21|20|19|18)\s*\+\b/);
            if (m) return \`\${m[1]}+\`;
            if (/\bunder\s*18\s*not\s*admitted\b/.test(t)) return '18+';
            return '';
          }

          function shouldKeepByName(name='') {
            const n = name || '';
            if (!n.trim()) return false;
            if (EXCLUDE_DEFUNCT_RE.test(n)) return false;
            if (EXCLUDE_VENUE_NAME_RE.test(n)) return false;
            if (EXCLUDE_CATEGORIES_RE.test(n)) return false;
            return true;
          }

          // ------------- Ticketmaster (seed list only, no TM links) -------------
          async function fetchTicketmasterVenuesWA(apiKey, maxPages=5) {
            const out = [];
            const size = 200;
            for (let page=0; page<maxPages; page++) {
              const url = \`https://app.ticketmaster.com/discovery/v2/venues.json?countryCode=US&stateCode=\${STATE}&size=\${size}&page=\${page}&apikey=\${encodeURIComponent(apiKey)}\`;
              const data = await fetchJSON(url, { 'User-Agent':'wa-venues-pipeline/1.4' });
              const venues = data?._embedded?.venues || [];
              if (!venues.length) break;

              for (const v of venues) {
                const name = (v.name||'').trim();
                const city = v.city?.name || '(Unknown City)';
                if (!shouldKeepByName(name)) continue;

                const childRule = v.generalInfo?.childRule || '';
                const generalRule = v.generalInfo?.generalRule || '';
                const age = extractAge(\`\${childRule}\n\${generalRule}\`);

                out.push({
                  name, city, state: STATE,
                  capacity: '', age,
                  region: REGION,
                  venueType: guessVenueType(name),
                  genres: '',
                  image: '', website: '',
                  social: [],
                  sources: ['Ticketmaster'],
                  id: v.id ? \`tmv-\${v.id}\` : '',
                  confidence: 75 + (age ? 3 : 0)
                });
              }
              if (venues.length < size) break;
              await new Promise(r=>setTimeout(r, 120));
            }
            return out;
          }

          // ------------- Wikidata (music-venue classes; adds P576 dissolved) -------------
          async function fetchWikidataWA() {
            const qidWA = 'Q1223';
            const classes = ['Q17350442','Q13219666','Q164432','Q15961988','Q15938568','Q171730']; // concert hall, music venue, etc.
            const sparql = `
            SELECT ?item ?itemLabel ?cityLabel ?website ?capacity ?image ?minage ?endtime ?facebook ?instagram ?twitter WHERE {
              VALUES ?class { ${classes.map(q=>`wd:${q}`).join(' ')} }
              ?item wdt:P31/wdt:P279* ?class .
              ?item wdt:P131* wd:${qidWA} .
              OPTIONAL { ?item wdt:P856 ?website. }
              OPTIONAL { ?item wdt:P1083 ?capacity. }
              OPTIONAL { ?item wdt:P18 ?image. }
              OPTIONAL { ?item wdt:P131 ?city. }
              OPTIONAL { ?item wdt:P2899 ?minage. }
              OPTIONAL { ?item wdt:P576 ?endtime. }          # dissolved/abolished
              OPTIONAL { ?item wdt:P2013 ?facebook. }
              OPTIONAL { ?item wdt:P2003 ?instagram. }
              OPTIONAL { ?item wdt:P2002 ?twitter. }
              SERVICE wikibase:label { bd:serviceParam wikibase:language "en". }
            }`;
            const url = 'https://query.wikidata.org/sparql?format=json&query=' + encodeURIComponent(sparql);
            const data = await fetchJSON(url, { 'User-Agent':'wa-venues-pipeline/1.4' });
            const rows = data?.results?.bindings || [];
            const out = [];
            for (const b of rows) {
              const name = (b.itemLabel?.value || '').trim();
              if (!name || !shouldKeepByName(name)) continue;
              const city = (b.cityLabel?.value || '(Unknown City)').trim();
              const website = (b.website?.value || '').trim();
              const capacity = b.capacity?.value ? Number(b.capacity.value) : '';
              const image = (b.image?.value || '').trim();
              const minage = b.minage?.value ? String(b.minage.value) : '';
              const age = minage ? \`\${minage}+\` : '';
              const endtime = b.endtime?.value || '';
              const social = [];
              if (b.facebook?.value) social.push(\`https://facebook.com/\${b.facebook.value}\`);
              if (b.instagram?.value) social.push(\`https://instagram.com/\${b.instagram.value}\`);
              if (b.twitter?.value) social.push(\`https://x.com/\${b.twitter.value}\`);

              const row = {
                name, city, state: STATE,
                capacity, age,
                region: REGION,
                venueType: guessVenueType(name),
                genres: '',
                image, website,
                social,
                sources: ['WikidataSPARQL'],
                id: 'wd-' + (b.item?.value?.split('/').pop() || ''),
                confidence: 92 + (website ? 3 : 0)
              };
              if (endtime) row._wdDefunct = true;
              out.push(row);
            }
            return out;
          }

          // ------------- Optional: discover official site if missing -------------
          async function discoverWebsiteBySearch(name, city, limit=1) {
            if (process.env.ENABLE_WEB_SEARCH !== '1') return '';
            const q = encodeURIComponent(\`\${name} \${city} official site\`);
            const url = \`https://html.duckduckgo.com/html/?q=\${q}\`;
            try {
              const html = await fetchText(url, { 'User-Agent':'wa-venues-pipeline/1.4' });
              const links = Array.from(html.matchAll(/<a[^>]+class="result__a"[^>]+href="([^"]+)"/g)).map(m=>m[1]);
              const blacklist = ['ticketmaster','facebook','instagram','x.com','twitter','bandsintown','songkick',
                                 'yelp','tripadvisor','google','wikipedia','wikidata','eventbrite','stubhub','map'];
              for (const href of links) {
                try {
                  const u = new URL(href);
                  const host = u.hostname.toLowerCase();
                  if (blacklist.some(b=>host.includes(b))) continue;
                  return u.origin;
                } catch {}
              }
            } catch {}
            return '';
          }

          // ------------- Logo & social extraction -------------
          function absolutize(base, href) { try { return new URL(href, base).toString(); } catch { return ''; } }
          function pickLogoFromHTML(baseUrl, html) {
            const candidates = [];
            for (const rel of ['icon','shortcut icon','apple-touch-icon','apple-touch-icon-precomposed','mask-icon']) {
              const re = new RegExp(\`<link[^>]+rel=["']?\${rel}["']?[^>]*href=["']([^"']+)["']\`, 'ig');
              let m; while ((m = re.exec(html))) candidates.push({src: absolutize(baseUrl, m[1]), score: 60});
            }
            { // og:image
              const re = /<meta[^>]+property=["']og:image["'][^>]*content=["']([^"']+)["']/ig;
              let m; while ((m = re.exec(html))) candidates.push({src: absolutize(baseUrl, m[1]), score: 55});
            }
            { // <img src *= logo
              const re = /<img[^>]+src=["']([^"']+)["'][^>]*>/ig;
              let m; while ((m = re.exec(html))) {
                const src = absolutize(baseUrl, m[1]);
                if (/logo/i.test(src)) candidates.push({src, score: 80});
              }
            }
            const ranked = [];
            const seen = new Set();
            for (const c of candidates) {
              const key = c.src.replace(/\?.*$/, '');
              if (seen.has(key)) continue;
              seen.add(key);
              ranked.push(c);
            }
            ranked.sort((a,b)=>b.score - a.score);
            return ranked[0]?.src || '';
          }

          async function enrichFromSite(rows, maxFetch=70) {
            let count = 0;
            for (const r of rows) {
              if (!r.website) continue;
              if (count >= maxFetch) break;
              try {
                const html = await fetchText(r.website, { 'User-Agent':'wa-venues-pipeline/1.4' });
                if (!r.image) {
                  const logo = pickLogoFromHTML(r.website, html);
                  if (logo) r.image = logo;
                }
                const social = r.social || [];
                const reLink = /<a[^>]+href=["']([^"']+)["'][^>]*>/ig;
                let m;
                while ((m = reLink.exec(html))) {
                  const href = m[1];
                  if (/instagram\.com\//i.test(href)) social.push(href);
                  else if (/facebook\.com\//i.test(href)) social.push(href);
                  else if (/(twitter\.com|x\.com)\//i.test(href)) social.push(href);
                }
                r.social = unique(social);
                // keep a hint of recent copyright year
                const years = Array.from(String(html).matchAll(/\b(20\d{2})\b/g)).map(m=>parseInt(m[1],10));
                if (years.length) r._copyright_year = Math.max(...years);
              } catch {}
              count++;
              await new Promise(res=>setTimeout(res, 200));
            }
            return rows;
          }

          // ------------- Event proof: detect upcoming shows -------------
          function parseDatesFromHTML(html) {
            const dates = new Set();

            // JSON-LD Event blocks
            const jsonld = Array.from(html.matchAll(/<script[^>]+type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/ig))
              .map(m=>m[1]);
            for (const block of jsonld) {
              try {
                const data = JSON.parse(block);
                const items = Array.isArray(data) ? data : [data];
                for (const it of items) {
                  const arr = Array.isArray(it) ? it : [it];
                  for (const x of arr) {
                    const types = Array.isArray(x['@type']) ? x['@type'] : [x['@type']];
                    if (types && types.includes('Event') && x.startDate) {
                      dates.add(String(x.startDate));
                    }
                    if (x.event && Array.isArray(x.event)) {
                      for (const e of x.event) if (e.startDate) dates.add(String(e.startDate));
                    }
                  }
                }
              } catch {}
            }

            // iCal links (.ics)
            const ical = Array.from(html.matchAll(/href=["']([^"']+\.ics(\?[^"']*)?)["']/ig)).map(m=>m[1]);
            ical.forEach(d=>dates.add(d));

            // Human-readable months
            const human = Array.from(html.matchAll(/\b(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec)[a-z]*\s+\d{1,2}(?:,\s*\d{4})?/ig)).map(m=>m[0]);
            human.forEach(d=>dates.add(d));

            return Array.from(dates);
          }

          function hasUpcomingDate(dates, lookaheadDays=180, now=new Date()) {
            const cutoff = new Date(now.getTime() + lookaheadDays*DAY_MS);
            for (const d of dates) {
              let dt = new Date(d);
              if (isNaN(dt)) {
                const tryD = Date.parse(d);
                if (!isNaN(tryD)) dt = new Date(tryD);
                else continue;
              }
              if (dt >= now && dt <= cutoff) return true;
            }
            return false;
          }

          async function siteHasUpcomingEvents(baseUrl, lookaheadDays=180) {
            const paths = ['', '/events', '/calendar', '/shows', '/concerts', '/schedule'];
            for (const p of paths) {
              try {
                const url = new URL(p || '/', baseUrl).toString();
                const html = await fetchText(url, { 'User-Agent':'wa-venues-pipeline/1.4' });
                const dates = parseDatesFromHTML(html);
                if (hasUpcomingDate(dates, lookaheadDays)) return { ok: true, html };
                if (dates.some(x => typeof x === 'string' && x.includes('.ics'))) return { ok: true, html };
                if (CLOSED_RE.test(html)) return { ok: false, html, closed: true };
              } catch {}
              await new Promise(r=>setTimeout(r, 150));
            }
            return { ok: false };
          }

          async function songkickHasUpcoming(name, city) {
            const key = process.env.SONGKICK_API_KEY;
            if (!key) return false;
            try {
              const q = encodeURIComponent(\`\${name} \${city}\`);
              const sUrl = \`https://api.songkick.com/api/3.0/search/venues.json?query=\${q}&apikey=\${key}\`;
              const s = await fetchJSON(sUrl);
              const venue = s?.resultsPage?.results?.venue?.[0];
              if (!venue?.id) return false;
              const calUrl = \`https://api.songkick.com/api/3.0/venues/\${venue.id}/calendar.json?apikey=\${key}\`;
              const cal = await fetchJSON(calUrl);
              const evts = cal?.resultsPage?.results?.event || [];
              const now = new Date();
              for (const e of evts) {
                const dt = new Date(e.start?.date || '');
                if (!isNaN(dt) && dt >= now) return true;
              }
            } catch {}
            return false;
          }

          // Evidence scoring & gating
          async function detectSiteEvidence(website, lookaheadDays=120) {
            let looksDefunct = false;
            let activeNow = false;
            let lastEventDate = null;
            const sources = new Set();

            const paths = ['', '/events', '/calendar', '/shows', '/concerts', '/schedule'];
            for (const p of paths) {
              let html = '';
              try {
                const url = new URL(p || '/', website).toString();
                html = await fetchText(url, { 'User-Agent':'wa-venues-pipeline/1.4' });
              } catch { continue; }

              if (CLOSED_RE.test(html)) looksDefunct = true;

              const dates = parseDatesFromHTML(html);
              if (dates.length) {
                const now = new Date();
                const futureDates = dates
                  .map(d => new Date(d))
                  .filter(d => !isNaN(d) && d >= now)
                  .sort((a,b)=>a-b);
                if (futureDates[0]) {
                  lastEventDate = futureDates[futureDates.length-1].toISOString().slice(0,10);
                  sources.add('site-dates');
                }
                if (html.includes('application/ld+json')) sources.add('site-jsonld');
                if (dates.some(x => typeof x === 'string' && x.includes('.ics'))) sources.add('site-ics');
              }

              const years = Array.from(String(html).matchAll(/\b(20\d{2})\b/g)).map(m=>parseInt(m[1],10));
              if (years.length) {
                const cy = Math.max(...years);
                const thisYear = new Date().getFullYear();
                if (cy >= thisYear - 1) activeNow = true;
              }
            }

            return { looksDefunct, activeNow, lastEventDate, siteSources: Array.from(sources) };
          }

          async function scoreAndFilter(rows, {requireThreshold=3, lookaheadDays=120, maxChecks=160} = {}) {
            const out = [];
            let checked = 0;

            for (const r of rows) {
              let score = 0;
              const evidence = new Set();

              // Wikidata class bias
              if (r.sources?.includes('WikidataSPARQL')) { score += 1; evidence.add('wikidata'); }
              if (r._wdDefunct) { score -= 2; evidence.add('wd-defunct'); }

              // Official site evidence
              if (r.website && checked < maxChecks) {
                try {
                  const { looksDefunct, activeNow, lastEventDate, siteSources } = await detectSiteEvidence(r.website, lookaheadDays);
                  if (looksDefunct) { score -= 2; evidence.add('site-closed'); }
                  if (activeNow) { score += 1; evidence.add('site-active'); }
                  if (siteSources.length && lastEventDate) {
                    const dt = new Date(lastEventDate);
                    const now = new Date();
                    const cutoff = new Date(now.getTime() + lookaheadDays*DAY_MS);
                    if (!isNaN(dt) && dt >= now && dt <= cutoff) {
                      score += 2; evidence.add('site-upcoming');
                    }
                  }
                  if (lastEventDate) r.last_event_date = lastEventDate;
                } catch {}
                checked++;
              }

              // Songkick confirmation
              if (await songkickHasUpcoming(r.name, r.city)) {
                score += 1; evidence.add('songkick');
              }

              r.evidence_score = score;
              r.evidence_sources = Array.from(evidence).sort().join('|');

              if (score >= requireThreshold) out.push(r);
            }
            return out;
          }

          function mergeAndDedupe(a, b) {
            const m = new Map();
            const put = (v) => {
              const k = key(v.name, v.city);
              if (!m.has(k)) { m.set(k, v); return; }
              const t = m.get(k);
              if (!t.website && v.website) t.website = v.website;
              if (!t.image && v.image) t.image = v.image;
              if (!t.capacity && v.capacity) t.capacity = v.capacity;
              if (!t.venueType && v.venueType) t.venueType = v.venueType;
              if (!t.age && v.age) t.age = v.age;
              t.social = Array.from(new Set([...(t.social||[]), ...(v.social||[])]));
              t.sources = Array.from(new Set([...(t.sources||[]), ...(v.sources||[])]));
              t.confidence = Math.max(t.confidence||0, v.confidence||0);
            };
            [...a, ...b].forEach(put);
            return [...m.values()].filter(v =>
              shouldKeepByName(v.name || '') &&
              !/\b(former|defunct|closed)\b/i.test(v.name || '')
            ).sort((x,y)=>
              x.state.localeCompare(y.state) ||
              x.city.localeCompare(y.city) ||
              x.name.localeCompare(y.name)
            );
          }

          function dedupeByDomain(rows) {
            const map = new Map();
            for (const r of rows) {
              const host = (() => {
                try { return r.website ? new URL(r.website).hostname.replace(/^www\./,'') : ''; } catch { return ''; }
              })();
              const key = \`\${r.name.toLowerCase()}||\${r.city.toLowerCase()}||\${host}\`;
              if (!map.has(key)) { map.set(key, r); continue; }
              const prev = map.get(key);
              const a = r.evidence_score ?? 0, b = prev.evidence_score ?? 0;
              if (a > b) map.set(key, r);
            }
            return Array.from(map.values());
          }

          function toCSV(rows) {
            const headers = [
              'Venue Name','City','State','Capacity','Age Restrictions','Region','Venue Type','Genres (top 3)',
              'Image','Website','Social Links','Source(s)','Venue ID','Confidence',
              'Evidence Score','Evidence Sources','Last Event Date'
            ];
            const lines = [headers.map(escapeCSV).join(',')];
            for (const r of rows) {
              lines.push([
                r.name, r.city, r.state, r.capacity, r.age, r.region, r.venueType, r.genres, r.image, r.website,
                (r.social||[]).join('|'), (r.sources||[]).join(';'), r.id, r.confidence,
                r.evidence_score ?? '', r.evidence_sources ?? '', r.last_event_date || ''
              ].map(escapeCSV).join(','));
            }
            return lines.join('\n')+'\n';
          }

          // Manual overrides
          async function applyOverrides(rows) {
            let block = [], allow = [];
            try {
              const raw = await fs.readFile('data/overrides.json','utf8');
              const json = JSON.parse(raw || '{}');
              block = json.blocklist || [];
              allow = json.allowlist || [];
            } catch {}
            // blocklist by "Name||City" OR domain
            const blocked = new Set(block.map(x=>String(x).toLowerCase()));
            const isBlocked = (r) => {
              const byPair = blocked.has(\`\${r.name.toLowerCase()}||\${r.city.toLowerCase()}\`);
              const byDomain = (() => {
                try {
                  const d = r.website ? new URL(r.website).hostname.replace(/^www\./,'').toLowerCase() : '';
                  return blocked.has(d);
                } catch { return false; }
              })();
              return byPair || byDomain;
            };
            // allowlist by "Name||City"
            const allowed = new Set(allow.map(x=>String(x).toLowerCase()));
            const isAllowed = (r) => allowed.has(\`\${r.name.toLowerCase()}||\${r.city.toLowerCase()}\`);

            // filter
            let out = rows.filter(r => !isBlocked(r));
            // ensure allowlisted are present
            const allowAdds = rows.filter(r => isAllowed(r) && !out.some(x=>x.name===r.name && x.city===r.city));
            out.push(...allowAdds);
            return out;
          }

          (async () => {
            try {
              const tmKey = process.env.TM_API_KEY;
              if (!tmKey) throw new Error('Missing TM_API_KEY env');

              const [tm, wd] = await Promise.all([
                fetchTicketmasterVenuesWA(tmKey, 5),
                fetchWikidataWA()
              ]);

              await fs.mkdir('data', { recursive: true });
              await fs.writeFile('data/tm_wa.csv', toCSV(tm));
              await fs.writeFile('data/wd_wa.csv', toCSV(wd));

              let combined = mergeAndDedupe(tm, wd);

              // Optional site discovery
              if (process.env.ENABLE_WEB_SEARCH === '1') {
                for (const r of combined) {
                  if (!r.website) {
                    r.website = await discoverWebsiteBySearch(r.name, r.city);
                    await new Promise(res=>setTimeout(res, 200));
                  }
                }
              }

              // Enrich logo + social
              combined = await enrichFromSite(combined, 80);

              // Score + filter by multi-signal evidence
              combined = await scoreAndFilter(combined, { requireThreshold: 3, lookaheadDays: 120, maxChecks: 160 });

              // Dedupe by domain & apply overrides
              combined = dedupeByDomain(combined);
              combined = await applyOverrides(combined);

              await fs.writeFile('data/combined_wa.csv', toCSV(combined));
              console.log(\`TM: \${tm.length}, WD: \${wd.length}, Final after scoring: \${combined.length}\`);
            } catch (e) {
              console.error(e);
              process.exit(1);
            }
          })();
          EOF

          node scripts/build_wa_csvs.js

      - name: Commit CSVs
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          commit_message: "chore: WA venues â€” multi-signal scoring, defunct checks, logos, age"
          file_pattern: data/*.csv
          branch: main
